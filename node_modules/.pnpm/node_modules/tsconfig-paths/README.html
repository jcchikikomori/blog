<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JCC Blog</title><meta name="description" content="JCC's Blog"><meta name="keywords" content="blog, web, mobile-friendly, static-page, html5, github-pages"><meta name="author" content="John Cyrill Corsanes"><meta property="og:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta property="og:url" content="https://jcchikikomori.github.io/blog"><meta property="og:site_name" content="JCC Blog"><meta property="og:description" content="JCC's Blog"><meta name="twitter:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta name="twitter:url" content="https://jcchikikomori.github.io/blog"><meta name="twitter:card" content="blog"><!--if lt IE 9script(src='https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js'
  integrity='sha512-UDJtJXfzfsiPPgnI5S1000FPLBHMhvzAMX15I+qG2E2OAzC9P1JzUwJOfnypXiOH7MRPaqzhPbBGDNNj7zBfoA==' crossorigin='anonymous')
script(src='https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js'
  integrity='sha512-qWVvreMuH9i0DrugcOtifxdtZVBBL0X75r9YweXsdCHtXUidlctw7NXg5KVP3ITPtqZ2S575A0wFkvgS2anqSA==' crossorigin='anonymous')--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.2/css/bulma.min.css" integrity="sha512-byErQdWdTqREz6DLAA9pCnLbdoGGhXfU6gm1c8bkf7F51JVmUBlayGe2A31VpXWQP+eiJ3ilTAZHCR3vmMyybA==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/blog/assets/scss/main.css"></head><body><div class="loading"></div><nav role="navigation" aria-label="main navigation" class="navbar"><div class="container"><div class="navbar-brand"><a href="/blog/" class="navbar-item"><div height="28" class="logo"></div></a><a role="button" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample" class="navbar-burger"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div id="navbarBasicExample" class="navbar-menu"><div class="navbar-start"><a href="/blog/" class="navbar-item">Home</a><a href="/blog/articles" class="navbar-item">Articles</a></div><div class="navbar-end"><a href="/blog/about" class="navbar-item">About</a></div></div></div></nav><div class="container is-fullhd"><section class="-maintenance hero is-warning"><div class="hero-body"><h1 class="title is-1">Hello!</h1><h2 class="subtitle is-2">This Blog is currently under development.</h2></div></section></div><div class="container"><div class="columns m-0"><div class="column"><div class="columns"><div class="column"><section class="section"><div class="container article-container is-full-hd"><div class="content article-content"><h1>Welcome!</h1><p>JCC's Blog</p><h1>tsconfig-paths</h1><p><a href="https://www.npmjs.com/package/tsconfig-paths"><img src="https://img.shields.io/npm/v/tsconfig-paths.svg?style=flat" alt="npm version"></a>
<a href="https://travis-ci.com/dividab/tsconfig-paths"><img src="https://travis-ci.com/dividab/tsconfig-paths.svg?branch=master&style=flat" alt="travis build"></a>
<a href="https://codecov.io/gh/dividab/tsconfig-paths"><img src="https://codecov.io/gh/dividab/tsconfig-paths/branch/master/graph/badge.svg" alt="Coverage Status"></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/github/license/dividab/tsconfig-paths.svg?style=flat" alt="MIT license"></a>
<a href="https://github.com/prettier/prettier"><img src="https://img.shields.io/badge/code_style-prettier-ff69b4.svg" alt="code style: prettier"></a></p>
<p>Use this to load modules whose location is specified in the <code>paths</code> section of <code>tsconfig.json</code>. Both loading at run-time and via API are supported.</p>
<p>Typescript by default mimics the Node.js runtime resolution strategy of modules. But it also allows the use of <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html">path mapping</a> which allows arbitrary module paths (that doesn&#39;t start with &quot;/&quot; or &quot;.&quot;) to be specified and mapped to physical paths in the filesystem. The typescript compiler can resolve these paths from <code>tsconfig</code> so it will compile OK. But if you then try to execute the compiled files with node (or ts-node), it will only look in the <code>node_modules</code> folders all the way up to the root of the filesystem and thus will not find the modules specified by <code>paths</code> in <code>tsconfig</code>.</p>
<p>If you require this package&#39;s <code>tsconfig-paths/register</code> module it will read the <code>paths</code> from <code>tsconfig.json</code> and convert node&#39;s module loading calls into to physcial file paths that node can load.</p>
<h2>How to install</h2><pre><code>yarn add --dev tsconfig-paths
</code></pre>
<p>or</p>
<pre><code>npm install --save-dev tsconfig-paths
</code></pre>
<h2>How to use</h2><h3>With node</h3><p><code>node -r tsconfig-paths/register main.js</code></p>
<h3>With ts-node</h3><p><code>ts-node -r tsconfig-paths/register main.ts</code></p>
<p>If <code>process.env.TS_NODE_PROJECT</code> is set it will be used to resolved tsconfig.json</p>
<h3>With webpack</h3><p>For webpack please use the <a href="https://github.com/dividab/tsconfig-paths-webpack-plugin">tsconfig-paths-webpack-plugin</a>.</p>
<h3>With mocha and ts-node</h3><p>As of Mocha &gt;= 4.0.0 the <code>--compiler</code> was <a href="https://github.com/mochajs/mocha/wiki/compilers-deprecation">deprecated</a>. Instead <code>--require</code> should be used. You also have to specify a glob that includes <code>.ts</code> files because mocha looks after files with <code>.js</code> extension by default.</p>
<pre><code class="language-bash">mocha -r ts-node/register -r tsconfig-paths/register &quot;test/**/*.ts&quot;
</code></pre>
<h3>With other commands</h3><p>As long as the command has something similar to a <code>--require</code> option that can load a module before it starts, tsconfig-paths should be able to work with it.</p>
<h2>Bootstraping with explicit params</h2><p>If you want more granular control over tsconfig-paths you can bootstrap it. This can be useful if you for instance have compiled with <code>tsc</code> to another directory where <code>tsconfig.json</code> doesn&#39;t exists.</p>
<pre><code class="language-javascript">const tsConfig = require(&quot;./tsconfig.json&quot;);
const tsConfigPaths = require(&quot;tsconfig-paths&quot;);

const baseUrl = &quot;./&quot;; // Either absolute or relative path. If relative it&#39;s resolved to current working directory.
const cleanup = tsConfigPaths.register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths
});

// When path registration is no longer needed
cleanup();
</code></pre>
<p>Then run with:</p>
<p><code>node -r ./tsconfig-paths-bootstrap.js main.js</code></p>
<h2>Configuration Options</h2><p>You can set options by passing them before the script path, via programmatic usage or via environment variables.</p>
<pre><code class="language-bash">ts-node --project customLocation/tsconfig.json -r tsconfig-paths/register &quot;test/**/*.ts&quot;
</code></pre>
<h3>CLI and Programmatic Options</h3><p><em>Environment variable denoted in parentheses.</em></p>
<ul>
<li><code>-P, --project [path]</code> Path to TypeScript JSON project file (<code>TS_NODE_PROJECT</code>)</li>
</ul>
<h2>Config loading process</h2><ol>
<li> Use explicit params passed to register</li>
<li> Use <code>process.env.TS_NODE_PROJECT</code> to resolve tsConfig.json and the specified baseUrl and paths.</li>
<li> Resolves tsconfig.json from current working directory and the specified baseUrl and paths.</li>
</ol>
<h2>Programmatic use</h2><p>The public API consists of these functions:</p>
<ul>
<li><a href="#register">register</a></li>
<li><a href="#loadConfig">loadConfig</a></li>
<li><a href="#createMatchPath">createMatchPath</a> / <a href="#createMatchPathAsync">createMatchPathAsync</a></li>
<li><a href="#matchFromAbsolutePaths">matchFromAbsolutePaths</a> / <a href="#matchFromAbsolutePathsAsync">matchFromAbsolutePathsAsync</a></li>
</ul>
<h3>register</h3><pre><code class="language-typescript">export interface ExplicitParams {
  baseUrl: string;
  paths: { [key: string]: Array&lt;string&gt; };
  mainFields?: Array&lt;string&gt;;
  addMatchAll?: boolean;
}

/**
 * Installs a custom module load function that can adhere to paths in tsconfig.
 */
export function register(explicitParams: ExplicitParams): () =&gt; void;
</code></pre>
<p>This function will patch the node&#39;s module loading so it will look for modules in paths specified by tsconfig.json.
A function is returned for you to reinstate Node&#39;s original module loading.</p>
<h3>loadConfig</h3><pre><code class="language-typescript">export function loadConfig(cwd: string = process.cwd()): ConfigLoaderResult;

export type ConfigLoaderResult =
  | ConfigLoaderSuccessResult
  | ConfigLoaderFailResult;

export interface ConfigLoaderSuccessResult {
  resultType: &quot;success&quot;;
  absoluteBaseUrl: string;
  paths: { [key: string]: Array&lt;string&gt; };
}

export interface ConfigLoaderFailResult {
  resultType: &quot;failed&quot;;
  message: string;
}
</code></pre>
<p>This function loads the tsconfig.json. It will start searching from the specified <code>cwd</code> directory. Passing the tsconfig.json file directly instead of a directory also works.</p>
<h3>createMatchPath</h3><pre><code class="language-typescript">/**
 * Function that can match a path
 */
export interface MatchPath {
  (
    requestedModule: string,
    readJson?: Filesystem.ReadJsonSync,
    fileExists?: (name: string) =&gt; boolean,
    extensions?: ReadonlyArray&lt;string&gt;
  ): string | undefined;
}

/**
 * Creates a function that can resolve paths according to tsconfig paths property.
 * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.
 * @param paths The paths as specified in tsconfig.
 * @param mainFields A list of package.json field names to try when resolving module files.
 * @param addMatchAll Add a match-all &quot;*&quot; rule if none is present
 * @returns a function that can resolve paths.
 */
export function createMatchPath(
  absoluteBaseUrl: string,
  paths: { [key: string]: Array&lt;string&gt; },
  mainFields: string[] = [&quot;main&quot;],
  addMatchAll: boolean = true
): MatchPath {
</code></pre>
<p>The <code>createMatchPath</code> function will create a function that can match paths. It accepts <code>baseUrl</code> and <code>paths</code> directly as they are specified in tsconfig and will handle resolving paths to absolute form. The created function has the signare specified by the type <code>MatchPath</code> above.</p>
<h3>matchFromAbsolutePaths</h3><pre><code class="language-typescript">/**
 * Finds a path from tsconfig that matches a module load request.
 * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.
 * @param requestedModule The required module name.
 * @param readJson Function that can read json from a path (useful for testing).
 * @param fileExists Function that checks for existance of a file at a path (useful for testing).
 * @param extensions File extensions to probe for (useful for testing).
 * @param mainFields A list of package.json field names to try when resolving module files.
 * @returns the found path, or undefined if no path was found.
 */
export function matchFromAbsolutePaths(
  absolutePathMappings: ReadonlyArray&lt;MappingEntry.MappingEntry&gt;,
  requestedModule: string,
  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,
  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,
  extensions: Array&lt;string&gt; = Object.keys(require.extensions),
  mainFields: string[] = [&quot;main&quot;]
): string | undefined {
</code></pre>
<p>This function is lower level and requries that the paths as already been resolved to absolute form and sorted in correct order into an array.</p>
<h3>createMatchPathAsync</h3><p>This is the async version of <code>createMatchPath</code>. It has the same signature but with a callback parameter for the result.</p>
<h3>matchFromAbsolutePathsAsync</h3><p>This is the async version of <code>matchFromAbsolutePaths</code>. It has the same signature but with a callback parameter for the result.</p>
<h2>How to publish</h2><pre><code>yarn version --patch
yarn version --minor
yarn version --major
</code></pre>
</div></div></section></div><div class="column is-one-quarter is-mobile"><section class="section"><div class="content has-text-left"><h1>Quick Links</h1><h2>Recent</h2><ol type="1"><li><a href="/blog/article/long-article">Long article</a><p>Published 2021-06-02, 06:02pm
(UTC/GMT)</p></li><li><a href="/blog/article/folder-sample">Another one but on folder</a><p>Published 2021-05-02, 12:30pm
(UTC/GMT)</p></li><li><a href="/blog/article/another-article">Another Article</a><p>Published 2021-05-02, 12:00am
(UTC/GMT)</p></li><br><a href="/blog/articles">See more..</a></ol></div></section></div></div></div></div></div><footer class="footer"><div class="container"><p>Copyright 2021</p><p>Version 0.1.5</p></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script><script type="text/javascript" src="/blog/assets/js/main.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53297367-3"></script></body></html>