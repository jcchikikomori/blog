<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JCC Blog</title><meta name="description" content="JCC's Blog"><meta name="keywords" content="blog, web, mobile-friendly, static-page, html5, github-pages"><meta name="author" content="John Cyrill Corsanes"><meta property="og:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta property="og:url" content="https://jcchikikomori.github.io/blog"><meta property="og:site_name" content="JCC Blog"><meta property="og:description" content="JCC's Blog"><meta name="twitter:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta name="twitter:url" content="https://jcchikikomori.github.io/blog"><meta name="twitter:card" content="blog"><!--if lt IE 9script(src='https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js'
  integrity='sha512-UDJtJXfzfsiPPgnI5S1000FPLBHMhvzAMX15I+qG2E2OAzC9P1JzUwJOfnypXiOH7MRPaqzhPbBGDNNj7zBfoA==' crossorigin='anonymous')
script(src='https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js'
  integrity='sha512-qWVvreMuH9i0DrugcOtifxdtZVBBL0X75r9YweXsdCHtXUidlctw7NXg5KVP3ITPtqZ2S575A0wFkvgS2anqSA==' crossorigin='anonymous')--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.2/css/bulma.min.css" integrity="sha512-byErQdWdTqREz6DLAA9pCnLbdoGGhXfU6gm1c8bkf7F51JVmUBlayGe2A31VpXWQP+eiJ3ilTAZHCR3vmMyybA==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/blog/assets/scss/main.css"></head><body><div class="loading"></div><nav role="navigation" aria-label="main navigation" class="navbar"><div class="container"><div class="navbar-brand"><a href="/blog/" class="navbar-item"><div height="28" class="logo"></div></a><a role="button" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample" class="navbar-burger"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div id="navbarBasicExample" class="navbar-menu"><div class="navbar-start"><a href="/blog/" class="navbar-item">Home</a><a href="/blog/articles" class="navbar-item">Articles</a></div><div class="navbar-end"><a href="/blog/about" class="navbar-item">About</a></div></div></div></nav><div class="container is-fullhd"><section class="-maintenance hero is-warning"><div class="hero-body"><h1 class="title is-1">Hello!</h1><h2 class="subtitle is-2">This Blog is currently under development.</h2></div></section></div><div class="container primary"><div class="columns m-0"><div class="column"><div class="columns"><div class="column"><section class="section"><div class="container article-container is-full-hd"><div class="content article-content"><h1>Welcome!</h1><p>JCC's Blog</p><h1>lru cache</h1><p>A cache object that deletes the least-recently-used items.</p>
<p><a href="https://travis-ci.org/isaacs/node-lru-cache"><img src="https://travis-ci.org/isaacs/node-lru-cache.svg?branch=master" alt="Build Status"></a> <a href="https://coveralls.io/github/isaacs/node-lru-cache"><img src="https://coveralls.io/repos/isaacs/node-lru-cache/badge.svg?service=github" alt="Coverage Status"></a></p>
<h2>Installation:</h2><pre><code class="language-javascript">npm install lru-cache --save
</code></pre>
<h2>Usage:</h2><pre><code class="language-javascript">var LRU = require(&quot;lru-cache&quot;)
  , options = { max: 500
              , length: function (n, key) { return n * 2 + key.length }
              , dispose: function (key, n) { n.close() }
              , maxAge: 1000 * 60 * 60 }
  , cache = new LRU(options)
  , otherCache = new LRU(50) // sets just the max size

cache.set(&quot;key&quot;, &quot;value&quot;)
cache.get(&quot;key&quot;) // &quot;value&quot;

// non-string keys ARE fully supported
// but note that it must be THE SAME object, not
// just a JSON-equivalent object.
var someObject = { a: 1 }
cache.set(someObject, &#39;a value&#39;)
// Object keys are not toString()-ed
cache.set(&#39;[object Object]&#39;, &#39;a different value&#39;)
assert.equal(cache.get(someObject), &#39;a value&#39;)
// A similar object with same keys/values won&#39;t work,
// because it&#39;s a different object identity
assert.equal(cache.get({ a: 1 }), undefined)

cache.reset()    // empty the cache
</code></pre>
<p>If you put more stuff in it, then items will fall out.</p>
<p>If you try to put an oversized thing in it, then it&#39;ll fall out right
away.</p>
<h2>Options</h2><ul>
<li><code>max</code> The maximum size of the cache, checked by applying the length
function to all values in the cache.  Not setting this is kind of
silly, since that&#39;s the whole purpose of this lib, but it defaults
to <code>Infinity</code>.  Setting it to a non-number or negative number will
throw a <code>TypeError</code>.  Setting it to 0 makes it be <code>Infinity</code>.</li>
<li><code>maxAge</code> Maximum age in ms.  Items are not pro-actively pruned out
as they age, but if you try to get an item that is too old, it&#39;ll
drop it and return undefined instead of giving it to you.
Setting this to a negative value will make everything seem old!
Setting it to a non-number will throw a <code>TypeError</code>.</li>
<li><code>length</code> Function that is used to calculate the length of stored
items.  If you&#39;re storing strings or buffers, then you probably want
to do something like <code>function(n, key){return n.length}</code>.  The default is
<code>function(){return 1}</code>, which is fine if you want to store <code>max</code>
like-sized things.  The item is passed as the first argument, and
the key is passed as the second argumnet.</li>
<li><code>dispose</code> Function that is called on items when they are dropped
from the cache.  This can be handy if you want to close file
descriptors or do other cleanup tasks when items are no longer
accessible.  Called with <code>key, value</code>.  It&#39;s called <em>before</em>
actually removing the item from the internal cache, so if you want
to immediately put it back in, you&#39;ll have to do that in a
<code>nextTick</code> or <code>setTimeout</code> callback or it won&#39;t do anything.</li>
<li><code>stale</code> By default, if you set a <code>maxAge</code>, it&#39;ll only actually pull
stale items out of the cache when you <code>get(key)</code>.  (That is, it&#39;s
not pre-emptively doing a <code>setTimeout</code> or anything.)  If you set
<code>stale:true</code>, it&#39;ll return the stale value before deleting it.  If
you don&#39;t set this, then it&#39;ll return <code>undefined</code> when you try to
get a stale entry, as if it had already been deleted.</li>
<li><code>noDisposeOnSet</code> By default, if you set a <code>dispose()</code> method, then
it&#39;ll be called whenever a <code>set()</code> operation overwrites an existing
key.  If you set this option, <code>dispose()</code> will only be called when a
key falls out of the cache, not when it is overwritten.</li>
<li><code>updateAgeOnGet</code> When using time-expiring entries with <code>maxAge</code>,
setting this to <code>true</code> will make each item&#39;s effective time update
to the current time whenever it is retrieved from cache, causing it
to not expire.  (It can still fall out of cache based on recency of
use, of course.)</li>
</ul>
<h2>API</h2><ul>
<li><p><code>set(key, value, maxAge)</code></p>
</li>
<li><p><code>get(key) =&gt; value</code></p>
<p>  Both of these will update the &quot;recently used&quot;-ness of the key.
  They do what you think. <code>maxAge</code> is optional and overrides the
  cache <code>maxAge</code> option if provided.</p>
<p>  If the key is not found, <code>get()</code> will return <code>undefined</code>.</p>
<p>  The key and val can be any value.</p>
</li>
<li><p><code>peek(key)</code></p>
<p>  Returns the key value (or <code>undefined</code> if not found) without
  updating the &quot;recently used&quot;-ness of the key.</p>
<p>  (If you find yourself using this a lot, you <em>might</em> be using the
  wrong sort of data structure, but there are some use cases where
  it&#39;s handy.)</p>
</li>
<li><p><code>del(key)</code></p>
<p>  Deletes a key out of the cache.</p>
</li>
<li><p><code>reset()</code></p>
<p>  Clear the cache entirely, throwing away all values.</p>
</li>
<li><p><code>has(key)</code></p>
<p>  Check if a key is in the cache, without updating the recent-ness
  or deleting it for being stale.</p>
</li>
<li><p><code>forEach(function(value,key,cache), [thisp])</code></p>
<p>  Just like <code>Array.prototype.forEach</code>.  Iterates over all the keys
  in the cache, in order of recent-ness.  (Ie, more recently used
  items are iterated over first.)</p>
</li>
<li><p><code>rforEach(function(value,key,cache), [thisp])</code></p>
<p>  The same as <code>cache.forEach(...)</code> but items are iterated over in
  reverse order.  (ie, less recently used items are iterated over
  first.)</p>
</li>
<li><p><code>keys()</code></p>
<p>  Return an array of the keys in the cache.</p>
</li>
<li><p><code>values()</code></p>
<p>  Return an array of the values in the cache.</p>
</li>
<li><p><code>length</code></p>
<p>  Return total length of objects in cache taking into account
  <code>length</code> options function.</p>
</li>
<li><p><code>itemCount</code></p>
<p>  Return total quantity of objects currently in cache. Note, that
  <code>stale</code> (see options) items are returned as part of this item
  count.</p>
</li>
<li><p><code>dump()</code></p>
<p>  Return an array of the cache entries ready for serialization and usage
  with &#39;destinationCache.load(arr)`.</p>
</li>
<li><p><code>load(cacheEntriesArray)</code></p>
<p>  Loads another cache entries array, obtained with <code>sourceCache.dump()</code>,
  into the cache. The destination cache is reset before loading new entries</p>
</li>
<li><p><code>prune()</code></p>
<p>  Manually iterates over the entire cache proactively pruning old entries</p>
</li>
</ul>
</div></div></section></div><div class="column is-one-quarter is-mobile"><section class="section"><div class="content has-text-left"><h1>Quick Links</h1><h2>Recent</h2><ol type="1"><li><a href="/blog/article/long-article">Long article</a><p>Published 2021-06-02, 06:02pm
(UTC/GMT)</p></li><li><a href="/blog/article/folder-sample">Another one but on folder</a><p>Published 2021-05-02, 12:30pm
(UTC/GMT)</p></li><li><a href="/blog/article/another-article">Another Article</a><p>Published 2021-05-02, 12:00am
(UTC/GMT)</p></li><br><a href="/blog/articles">See more..</a></ol></div></section></div></div></div></div></div><footer class="footer"><div class="container"><p>Copyright 2021</p><p>Version 0.1.5</p></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script><script type="text/javascript" src="/blog/assets/js/main.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53297367-3"></script></body></html>