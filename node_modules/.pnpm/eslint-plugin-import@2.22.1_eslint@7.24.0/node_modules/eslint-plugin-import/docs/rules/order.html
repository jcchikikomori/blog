<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JCC Blog</title><meta name="description" content="JCC's Blog"><meta name="keywords" content="blog, web, mobile-friendly, static-page, html5, github-pages"><meta name="author" content="John Cyrill Corsanes"><meta property="og:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta property="og:url" content="https://jcchikikomori.github.io/blog"><meta property="og:site_name" content="JCC Blog"><meta property="og:description" content="JCC's Blog"><meta name="twitter:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta name="twitter:url" content="https://jcchikikomori.github.io/blog"><meta name="twitter:card" content="blog"><!--if lt IE 9script(src='https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js'
  integrity='sha512-UDJtJXfzfsiPPgnI5S1000FPLBHMhvzAMX15I+qG2E2OAzC9P1JzUwJOfnypXiOH7MRPaqzhPbBGDNNj7zBfoA==' crossorigin='anonymous')
script(src='https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js'
  integrity='sha512-qWVvreMuH9i0DrugcOtifxdtZVBBL0X75r9YweXsdCHtXUidlctw7NXg5KVP3ITPtqZ2S575A0wFkvgS2anqSA==' crossorigin='anonymous')--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.2/css/bulma.min.css" integrity="sha512-byErQdWdTqREz6DLAA9pCnLbdoGGhXfU6gm1c8bkf7F51JVmUBlayGe2A31VpXWQP+eiJ3ilTAZHCR3vmMyybA==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/blog/assets/scss/main.css"></head><body><div class="loading"></div><nav role="navigation" aria-label="main navigation" class="navbar"><div class="container"><div class="navbar-brand"><a href="/blog/" class="navbar-item"><div height="28" class="logo"></div></a><a role="button" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample" class="navbar-burger"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div id="navbarBasicExample" class="navbar-menu"><div class="navbar-start"><a href="/blog/" class="navbar-item">Home</a><a href="/blog/articles" class="navbar-item">Articles</a></div><div class="navbar-end"><a href="/blog/about" class="navbar-item">About</a></div></div></div></nav><div class="container is-fullhd"><section class="-maintenance hero is-warning"><div class="hero-body"><h1 class="title is-1">Hello!</h1><h2 class="subtitle is-2">This Blog is currently under development.</h2></div></section></div><div class="container primary"><div class="columns m-0"><div class="column"><div class="columns"><div class="column"><section class="section"><div class="container article-container is-full-hd"><div class="content article-content"><h1>Welcome!</h1><p>JCC's Blog</p><h1>import/order: Enforce a convention in module import order</h1><p>Enforce a convention in the order of <code>require()</code> / <code>import</code> statements.
+(fixable) The <code>--fix</code> option on the [command line] automatically fixes problems reported by this rule.
The order is as shown in the following example:</p>
<pre><code class="language-js">// 1. node &quot;builtin&quot; modules
import fs from &#39;fs&#39;;
import path from &#39;path&#39;;
// 2. &quot;external&quot; modules
import _ from &#39;lodash&#39;;
import chalk from &#39;chalk&#39;;
// 3. &quot;internal&quot; modules
// (if you have configured your path or webpack to handle your internal paths differently)
import foo from &#39;src/foo&#39;;
// 4. modules from a &quot;parent&quot; directory
import foo from &#39;../foo&#39;;
import qux from &#39;../../foo/qux&#39;;
// 5. &quot;sibling&quot; modules from the same or a sibling&#39;s directory
import bar from &#39;./bar&#39;;
import baz from &#39;./bar/baz&#39;;
// 6. &quot;index&quot; of the current directory
import main from &#39;./&#39;;
// 7. &quot;object&quot;-imports (only available in TypeScript)
import log = console.log;
</code></pre>
<p>Unassigned imports are ignored, as the order they are imported in may be important.</p>
<p>Statements using the ES6 <code>import</code> syntax must appear before any <code>require()</code> statements.</p>
<h2>Fail</h2><pre><code class="language-js">import _ from &#39;lodash&#39;;
import path from &#39;path&#39;; // `path` import should occur before import of `lodash`

// -----

var _ = require(&#39;lodash&#39;);
var path = require(&#39;path&#39;); // `path` import should occur before import of `lodash`

// -----

var path = require(&#39;path&#39;);
import foo from &#39;./foo&#39;; // `import` statements must be before `require` statement
</code></pre>
<h2>Pass</h2><pre><code class="language-js">import path from &#39;path&#39;;
import _ from &#39;lodash&#39;;

// -----

var path = require(&#39;path&#39;);
var _ = require(&#39;lodash&#39;);

// -----

// Allowed as Ì€`babel-register` is not assigned.
require(&#39;babel-register&#39;);
var path = require(&#39;path&#39;);

// -----

// Allowed as `import` must be before `require`
import foo from &#39;./foo&#39;;
var path = require(&#39;path&#39;);
</code></pre>
<h2>Options</h2><p>This rule supports the following options:</p>
<h3><code>groups: [array]</code>:</h3><p>How groups are defined, and the order to respect. <code>groups</code> must be an array of <code>string</code> or [<code>string</code>]. The only allowed <code>string</code>s are:
<code>&quot;builtin&quot;</code>, <code>&quot;external&quot;</code>, <code>&quot;internal&quot;</code>, <code>&quot;unknown&quot;</code>, <code>&quot;parent&quot;</code>, <code>&quot;sibling&quot;</code>, <code>&quot;index&quot;</code>, <code>&quot;object&quot;</code>.
The enforced order is the same as the order of each element in a group. Omitted types are implicitly grouped together as the last element. Example:</p>
<pre><code class="language-js">[
  &#39;builtin&#39;, // Built-in types are first
  [&#39;sibling&#39;, &#39;parent&#39;], // Then sibling and parent types. They can be mingled together
  &#39;index&#39;, // Then the index file
  &#39;object&#39;,
  // Then the rest: internal and external type
]
</code></pre>
<p>The default value is <code>[&quot;builtin&quot;, &quot;external&quot;, &quot;parent&quot;, &quot;sibling&quot;, &quot;index&quot;]</code>.</p>
<p>You can set the options like this:</p>
<pre><code class="language-js">&quot;import/order&quot;: [&quot;error&quot;, {&quot;groups&quot;: [&quot;index&quot;, &quot;sibling&quot;, &quot;parent&quot;, &quot;internal&quot;, &quot;external&quot;, &quot;builtin&quot;, &quot;object&quot;]}]
</code></pre>
<h3><code>pathGroups: [array of objects]</code>:</h3><p>To be able to group by paths mostly needed with aliases pathGroups can be defined.</p>
<p>Properties of the objects</p>
<table>
<thead>
<tr>
<th>property</th>
<th align="center">required</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>pattern</td>
<td align="center">x</td>
<td>string</td>
<td>minimatch pattern for the paths to be in this group (will not be used for builtins or externals)</td>
</tr>
<tr>
<td>patternOptions</td>
<td align="center"></td>
<td>object</td>
<td>options for minimatch, default: { nocomment: true }</td>
</tr>
<tr>
<td>group</td>
<td align="center">x</td>
<td>string</td>
<td>one of the allowed groups, the pathGroup will be positioned relative to this group</td>
</tr>
<tr>
<td>position</td>
<td align="center"></td>
<td>string</td>
<td>defines where around the group the pathGroup will be positioned, can be &#39;after&#39; or &#39;before&#39;, if not provided pathGroup will be positioned like the group</td>
</tr>
</tbody></table>
<pre><code class="language-json">{
  &quot;import/order&quot;: [&quot;error&quot;, {
    &quot;pathGroups&quot;: [
      {
        &quot;pattern&quot;: &quot;~/**&quot;,
        &quot;group&quot;: &quot;external&quot;
      }
    ]
  }]
}
</code></pre>
<h3><code>pathGroupsExcludedImportTypes: [array]</code>:</h3><p>This defines import types that are not handled by configured pathGroups.
This is mostly needed when you want to handle path groups that look like external imports.</p>
<p>Example:</p>
<pre><code class="language-json">{
  &quot;import/order&quot;: [&quot;error&quot;, {
    &quot;pathGroups&quot;: [
      {
        &quot;pattern&quot;: &quot;@app/**&quot;,
        &quot;group&quot;: &quot;external&quot;,
        &quot;position&quot;: &quot;after&quot;
      }
    ],
    &quot;pathGroupsExcludedImportTypes&quot;: [&quot;builtin&quot;]
  }]
}
</code></pre>
<p>The default value is <code>[&quot;builtin&quot;, &quot;external&quot;]</code>.</p>
<h3><code>newlines-between: [ignore|always|always-and-inside-groups|never]</code>:</h3><p>Enforces or forbids new lines between import groups:</p>
<ul>
<li>If set to <code>ignore</code>, no errors related to new lines between import groups will be reported (default).</li>
<li>If set to <code>always</code>, at least one new line between each group will be enforced, and new lines inside a group will be forbidden. To prevent multiple lines between imports, core <code>no-multiple-empty-lines</code> rule can be used.</li>
<li>If set to <code>always-and-inside-groups</code>, it will act like <code>always</code> except newlines are allowed inside import groups.</li>
<li>If set to <code>never</code>, no new lines are allowed in the entire import section.</li>
</ul>
<p>With the default group setting, the following will be invalid:</p>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;always&quot;}] */
import fs from &#39;fs&#39;;
import path from &#39;path&#39;;
import index from &#39;./&#39;;
import sibling from &#39;./foo&#39;;
</code></pre>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;always-and-inside-groups&quot;}] */
import fs from &#39;fs&#39;;

import path from &#39;path&#39;;
import index from &#39;./&#39;;
import sibling from &#39;./foo&#39;;
</code></pre>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;never&quot;}] */
import fs from &#39;fs&#39;;
import path from &#39;path&#39;;

import index from &#39;./&#39;;

import sibling from &#39;./foo&#39;;
</code></pre>
<p>while those will be valid:</p>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;always&quot;}] */
import fs from &#39;fs&#39;;
import path from &#39;path&#39;;

import index from &#39;./&#39;;

import sibling from &#39;./foo&#39;;
</code></pre>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;always-and-inside-groups&quot;}] */
import fs from &#39;fs&#39;;

import path from &#39;path&#39;;

import index from &#39;./&#39;;

import sibling from &#39;./foo&#39;;
</code></pre>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;newlines-between&quot;: &quot;never&quot;}] */
import fs from &#39;fs&#39;;
import path from &#39;path&#39;;
import index from &#39;./&#39;;
import sibling from &#39;./foo&#39;;
</code></pre>
<h3><code>alphabetize: {order: asc|desc|ignore, caseInsensitive: true|false}</code>:</h3><p>Sort the order within each group in alphabetical manner based on <strong>import path</strong>:</p>
<ul>
<li><code>order</code>: use <code>asc</code> to sort in ascending order, and <code>desc</code> to sort in descending order (default: <code>ignore</code>).</li>
<li><code>caseInsensitive</code>: use <code>true</code> to ignore case, and <code>false</code> to consider case (default: <code>false</code>).</li>
</ul>
<p>Example setting:</p>
<pre><code class="language-js">alphabetize: {
  order: &#39;asc&#39;, /* sort in ascending order. Options: [&#39;ignore&#39;, &#39;asc&#39;, &#39;desc&#39;] */
  caseInsensitive: true /* ignore case. Options: [true, false] */
}
</code></pre>
<p>This will fail the rule check:</p>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;alphabetize&quot;: {&quot;order&quot;: &quot;asc&quot;, &quot;caseInsensitive&quot;: true}}] */
import React, { PureComponent } from &#39;react&#39;;
import aTypes from &#39;prop-types&#39;;
import { compose, apply } from &#39;xcompose&#39;;
import * as classnames from &#39;classnames&#39;;
import blist from &#39;BList&#39;;
</code></pre>
<p>While this will pass:</p>
<pre><code class="language-js">/* eslint import/order: [&quot;error&quot;, {&quot;alphabetize&quot;: {&quot;order&quot;: &quot;asc&quot;, &quot;caseInsensitive&quot;: true}}] */
import blist from &#39;BList&#39;;
import * as classnames from &#39;classnames&#39;;
import aTypes from &#39;prop-types&#39;;
import React, { PureComponent } from &#39;react&#39;;
import { compose, apply } from &#39;xcompose&#39;;
</code></pre>
<h2>Related</h2><ul>
<li><p><a href="../../README.md#importexternal-module-folders"><code>import/external-module-folders</code></a> setting</p>
</li>
<li><p><a href="../../README.md#importinternal-regex"><code>import/internal-regex</code></a> setting</p>
</li>
</ul>
</div></div></section></div><div class="column is-one-quarter is-mobile"><section class="section"><div class="content has-text-left"><h1>Quick Links</h1><h2>Recent</h2><ol type="1"><li><a href="/blog/article/long-article">Long article</a><p>Published 2021-06-02, 06:02pm
(UTC/GMT)</p></li><li><a href="/blog/article/folder-sample">Another one but on folder</a><p>Published 2021-05-02, 12:30pm
(UTC/GMT)</p></li><li><a href="/blog/article/another-article">Another Article</a><p>Published 2021-05-02, 12:00am
(UTC/GMT)</p></li><br><a href="/blog/articles">See more..</a></ol></div></section></div></div></div></div></div><footer class="footer"><div class="container"><p>Copyright 2021</p><p>Version 0.1.5</p></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script><script type="text/javascript" src="/blog/assets/js/main.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53297367-3"></script></body></html>