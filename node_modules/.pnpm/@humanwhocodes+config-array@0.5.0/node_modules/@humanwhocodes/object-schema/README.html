<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JCC Blog</title><meta name="description" content="JCC's Blog"><meta name="keywords" content="blog, web, mobile-friendly, static-page, html5, github-pages"><meta name="author" content="John Cyrill Corsanes"><meta property="og:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta property="og:url" content="https://jcchikikomori.github.io/blog"><meta property="og:site_name" content="JCC Blog"><meta property="og:description" content="JCC's Blog"><meta name="twitter:image" content="https://jcchikikomori.github.io/portfolio/img/jcc_logo.jpg"><meta name="twitter:url" content="https://jcchikikomori.github.io/blog"><meta name="twitter:card" content="blog"><!--if lt IE 9script(src='https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js'
  integrity='sha512-UDJtJXfzfsiPPgnI5S1000FPLBHMhvzAMX15I+qG2E2OAzC9P1JzUwJOfnypXiOH7MRPaqzhPbBGDNNj7zBfoA==' crossorigin='anonymous')
script(src='https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js'
  integrity='sha512-qWVvreMuH9i0DrugcOtifxdtZVBBL0X75r9YweXsdCHtXUidlctw7NXg5KVP3ITPtqZ2S575A0wFkvgS2anqSA==' crossorigin='anonymous')--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.3/css/bulma.min.css" integrity="sha512-IgmDkwzs96t4SrChW29No3NXBIBv8baW490zk5aXvhCD8vuZM3yUSkbyTBcXohkySecyzIrUwiF/qV0cuPcL3Q==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/blog/assets/scss/bulma-prefers-dark.css"><link rel="stylesheet" href="/blog/assets/scss/main.css"></head><body><div class="loading"></div><nav role="navigation" aria-label="main navigation" class="navbar"><div class="container"><div class="navbar-brand"><a href="/blog/" class="navbar-item"><div height="28" class="logo"></div></a><a role="button" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample" class="navbar-burger"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div id="navbarBasicExample" class="navbar-menu"><div class="navbar-start"><a href="/blog/" class="navbar-item">Home</a><a href="/blog/articles" class="navbar-item">Articles</a></div><div class="navbar-end"><a href="/blog/about" class="navbar-item">About</a></div></div></div></nav><div class="container is-fullhd"><section class="-maintenance hero is-warning"><div class="hero-body"><h1 class="title is-1">Hello!</h1><h2 class="subtitle is-2">This Blog is currently under development.</h2></div></section></div><div class="container primary"><div class="columns m-0"><div class="column"><div class="columns"><div class="column"><section class="section"><div class="container article-container is-full-hd"><div class="content article-content"><h1>Welcome!</h1><p>JCC's Blog</p><h1>JavaScript ObjectSchema Package</h1><p>by <a href="https://humanwhocodes.com">Nicholas C. Zakas</a></p>
<p>If you find this useful, please consider supporting my work with a <a href="https://humanwhocodes.com/donate">donation</a>.</p>
<h2>Overview</h2><p>A JavaScript object merge/validation utility where you can define a different merge and validation strategy for each key. This is helpful when you need to validate complex data structures and then merge them in a way that is more complex than <code>Object.assign()</code>.</p>
<h2>Installation</h2><p>You can install using either npm:</p>
<pre><code>npm install @humanwhocodes/object-schema
</code></pre>
<p>Or Yarn:</p>
<pre><code>yarn add @humanwhocodes/object-schema
</code></pre>
<h2>Usage</h2><p>Use CommonJS to get access to the <code>ObjectSchema</code> constructor:</p>
<pre><code class="language-js">const { ObjectSchema } = require(&quot;@humanwhocodes/object-schema&quot;);

const schema = new ObjectSchema({

    // define a definition for the &quot;downloads&quot; key
    downloads: {
        required: true,
        merge(value1, value2) {
            return value1 + value2;
        },
        validate(value) {
            if (typeof value !== &quot;number&quot;) {
                throw new Error(&quot;Expected downloads to be a number.&quot;);
            }
        }
    },

    // define a strategy for the &quot;versions&quot; key
    version: {
        required: true,
        merge(value1, value2) {
            return value1.concat(value2);
        },
        validate(value) {
            if (!Array.isArray(value)) {
                throw new Error(&quot;Expected versions to be an array.&quot;);
            }
        }
    }
});

const record1 = {
    downloads: 25,
    versions: [
        &quot;v1.0.0&quot;,
        &quot;v1.1.0&quot;,
        &quot;v1.2.0&quot;
    ]
};

const record2 = {
    downloads: 125,
    versions: [
        &quot;v2.0.0&quot;,
        &quot;v2.1.0&quot;,
        &quot;v3.0.0&quot;
    ]
};

// make sure the records are valid
schema.validate(record1);
schema.validate(record2);

// merge together (schema.merge() accepts any number of objects)
const result = schema.merge(record1, record2);

// result looks like this:

const result = {
    downloads: 75,
    versions: [
        &quot;v1.0.0&quot;,
        &quot;v1.1.0&quot;,
        &quot;v1.2.0&quot;,
        &quot;v2.0.0&quot;,
        &quot;v2.1.0&quot;,
        &quot;v3.0.0&quot;
    ]
};
</code></pre>
<h2>Tips and Tricks</h2><h3>Named merge strategies</h3><p>Instead of specifying a <code>merge()</code> method, you can specify one of the following strings to use a default merge strategy:</p>
<ul>
<li><code>&quot;assign&quot;</code> - use <code>Object.assign()</code> to merge the two values into one object.</li>
<li><code>&quot;overwrite&quot;</code> - the second value always replaces the first.</li>
<li><code>&quot;replace&quot;</code> - the second value replaces the first if the second is not <code>undefined</code>.</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">const schema = new ObjectSchema({
    name: {
        merge: &quot;replace&quot;,
        validate() {}
    }
});
</code></pre>
<h3>Named validation strategies</h3><p>Instead of specifying a <code>validate()</code> method, you can specify one of the following strings to use a default validation strategy:</p>
<ul>
<li><code>&quot;array&quot;</code> - value must be an array.</li>
<li><code>&quot;boolean&quot;</code> - value must be a boolean.</li>
<li><code>&quot;number&quot;</code> - value must be a number.</li>
<li><code>&quot;object&quot;</code> - value must be an object.</li>
<li><code>&quot;object?&quot;</code> - value must be an object or null.</li>
<li><code>&quot;string&quot;</code> - value must be a string.</li>
<li><code>&quot;string!&quot;</code> - value must be a non-empty string.</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">const schema = new ObjectSchema({
    name: {
        merge: &quot;replace&quot;,
        validate: &quot;string&quot;
    }
});
</code></pre>
<h3>Subschemas</h3><p>If you are defining a key that is, itself, an object, you can simplify the process by using a subschema. Instead of defining <code>merge()</code> and <code>validate()</code>, assign a <code>schema</code> key that contains a schema definition, like this:</p>
<pre><code class="language-js">const schema = new ObjectSchema({
    name: {
        schema: {
            first: {
                merge: &quot;replace&quot;,
                validate: &quot;string&quot;
            },
            last: {
                merge: &quot;replace&quot;,
                validate: &quot;string&quot;
            }
        }
    }
});

schema.validate({
    name: {
        first: &quot;n&quot;,
        last: &quot;z&quot;
    }
});
</code></pre>
<h3>Remove Keys During Merge</h3><p>If the merge strategy for a key returns <code>undefined</code>, then the key will not appear in the final object. For example:</p>
<pre><code class="language-js">const schema = new ObjectSchema({
    date: {
        merge() {
            return undefined;
        },
        validate(value) {
            Date.parse(value);  // throws an error when invalid
        }
    }
});

const object1 = { date: &quot;5/5/2005&quot; };
const object2 = { date: &quot;6/6/2006&quot; };

const result = schema.merge(object1, object2);

console.log(&quot;date&quot; in result);  // false
</code></pre>
<h3>Requiring Another Key Be Present</h3><p>If you&#39;d like the presence of one key to require the presence of another key, you can use the <code>requires</code> property to specify an array of other properties that any key requires. For example:</p>
<pre><code class="language-js">const schema = new ObjectSchema();

const schema = new ObjectSchema({
    date: {
        merge() {
            return undefined;
        },
        validate(value) {
            Date.parse(value);  // throws an error when invalid
        }
    },
    time: {
        requires: [&quot;date&quot;],
        merge(first, second) {
            return second;
        },
        validate(value) {
            // ...
        }
    }
});

// throws error: Key &quot;time&quot; requires keys &quot;date&quot;
schema.validate({
    time: &quot;13:45&quot;
});
</code></pre>
<p>In this example, even though <code>date</code> is an optional key, it is required to be present whenever <code>time</code> is present.</p>
<h2>License</h2><p>BSD 3-Clause</p>
</div></div></section></div><div class="column is-one-quarter is-mobile"><section class="section"><div class="content has-text-left"><h2>Recent</h2><ol type="1"><li><a href="/blog/article/google-alternatives-for-huawei-devices">Google alternatives for Huawei devices</a><p>Published 2020-11-20, 
(UTC/GMT)</p></li><li><a href="/blog/article/shifting-to-php-to-r">From Static to Dynamic</a><p>Published 2019-12-14, 
(UTC/GMT)</p></li><li><a href="/blog/article/long-article">Long article</a><p>Published 2021-06-02, 06:02pm
(UTC/GMT)</p></li><br><a href="/blog/articles">See more..</a></ol></div></section></div></div></div></div></div><footer class="footer"><div class="container"><p>Copyright 2021</p><p>Version 0.1.7</p></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script><script type="text/javascript" src="/blog/assets/js/main.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53297367-3"></script></body></html>